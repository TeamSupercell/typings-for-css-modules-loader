// @ts-check
/// <reference types="jest" />
const webpack = require("webpack");
const path = require("path");
const { Volume } = require("memfs");

beforeEach(() => {
  jest.mock("../src/persist");
  jest.mock("../src/verify");
});

describe("css-loader@latest", () => {
  const runTest = createTestRunner();

  it("default options", async () => {
    await runTest();

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();

    const verifyMock = jest.requireMock("../src/verify");
    expect(verifyMock).toBeCalledTimes(0);
  });

  it("with sourcemap", async () => {
    await runTest({
      cssLoaderOptions: {
        sourceMap: true,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("no locals in output", async () => {
    await runTest({
      fileName: "./example-no-locals.css",
      cssLoaderOptions: {
        sourceMap: true,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(0);
  });

  it("no modules", async () => {
    await runTest({
      cssLoaderOptions: {
        modules: false,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(0);
  });

  it("localsConvention asIs", async () => {
    await runTest({
      cssLoaderOptions: {
        modules: {
          exportLocalsConvention: "asIs",
        },
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("localsConvention camelCase", async () => {
    await runTest({
      cssLoaderOptions: {
        modules: {
          exportLocalsConvention: "camelCase",
        },
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with prettier", async () => {
    await runTest({
      options: {
        formatter: "prettier",
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with no formatter", async () => {
    await runTest({
      options: {
        formatter: "none",
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with banner", async () => {
    await runTest({
      options: {
        banner: "// autogenerated by typings-for-css-modules-loader",
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with locals export disabled", async () => {
    await runTest({
      options: {
        disableLocalsExport: true,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with verify only", async () => {
    await runTest({
      options: {
        verifyOnly: true,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(0);

    const verifyMock = jest.requireMock("../src/verify");
    expect(verifyMock).toBeCalledTimes(1);
  });
});

describe("css-loader@3", () => {
  const runTest = createTestRunner("css-loader3");

  it("default options", async () => {
    await runTest();

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();

    const verifyMock = jest.requireMock("../src/verify");
    expect(verifyMock).toBeCalledTimes(0);
  });

  it("with sourcemap", async () => {
    await runTest({
      cssLoaderOptions: {
        sourceMap: true,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("no locals in output", async () => {
    await runTest({
      fileName: "./example-no-locals.css",
      cssLoaderOptions: {
        sourceMap: true,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(0);
  });

  it("no modules", async () => {
    await runTest({
      cssLoaderOptions: {
        modules: false,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(0);
  });

  it("localsConvention asIs", async () => {
    await runTest({
      cssLoaderOptions: {
        localsConvention: "asIs",
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("localsConvention camelCase", async () => {
    await runTest({
      cssLoaderOptions: {
        localsConvention: "camelCase",
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with prettier", async () => {
    await runTest({
      options: {
        formatter: "prettier",
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with no formatter", async () => {
    await runTest({
      options: {
        formatter: "none",
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with banner", async () => {
    await runTest({
      options: {
        banner: "// autogenerated by typings-for-css-modules-loader",
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with locals export disabled", async () => {
    await runTest({
      options: {
        disableLocalsExport: true,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(1);
    expect(persistMock.mock.calls[0][1]).toMatchSnapshot();
  });

  it("with verify only", async () => {
    await runTest({
      options: {
        verifyOnly: true,
      },
    });

    const persistMock = jest.requireMock("../src/persist");
    expect(persistMock).toBeCalledTimes(0);

    const verifyMock = jest.requireMock("../src/verify");
    expect(verifyMock).toBeCalledTimes(1);
  });
});

function createTestRunner(cssLoaderModule = "css-loader") {
  return async ({
    fileName = "./example.css",
    options = {},
    cssLoaderOptions = {},
  } = {}) => {
    const compiler = webpack({
      entry: path.resolve(__dirname, fileName),
      target: "node",
      module: {
        rules: [
          {
            test: /\.css$/,
            use: [
              {
                loader: require.resolve("../src/index.js"),
                options,
              },
              {
                loader: cssLoaderModule,
                options: Object.assign(
                  {
                    modules: true,
                  },
                  cssLoaderOptions
                ),
              },
            ],
          },
        ],
      },
      mode: "none",
    });

    compiler.outputFileSystem = new Volume();

    /** @type {webpack.Stats} */
    const stats = await new Promise((resolve, reject) => {
      compiler.run((err, stats) => {
        if (err) {
          reject(err);
        } else {
          resolve(stats);
        }
      });
    });

    const s = stats.toJson();
    expect(s.errors).toHaveLength(0);
  };
}
